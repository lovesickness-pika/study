### spring事务的传播行为和隔离级别



#### 事务传播行为

- 就是指执行某个事务方法（就是用Transactional注解标注的方法）时，该方法的事务管理

- 有以下7种事务传播行为，在使用时使用注解**@Transactional(propagation=Propafation.REQUIRED)**标注

```java
public enum Propagation {
    REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);

    private final int value;
	...

}
```



- 在不同的事务传播行为下，事务管理器有不同的行为

| spring传播行为    | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| REQUIRED(default) | 业务方法需要在一个事务中运行,如果方法运行时,已处在一个事务中,那么就加入该事务,否则自己创建一个新的事务.这是spring默认的传播行为. |
| SUPPORTS          | 如果业务方法在某个事务范围内被调用,则方法成为该事务的一部分,如果业务方法在事务范围外被调用,则方法在没有事务的环境下执行. |
| MANDATORY         | 只能在一个已存在事务中执行,业务方法不能发起自己的事务,如果业务方法在没有事务的环境下调用,就抛异常 |
| REQUIRES_NEW      | 业务方法总是会为自己发起一个新的事务,如果方法已运行在一个事务中,则原有事务被挂起,新的事务被创建,直到方法结束,新事务才结束,原先的事务才会恢复执行. |
| NOT_SUPPORTED     | 业务方法总是会为自己发起一个新的事务,如果方法已运行在一个事务中,则原有事务被挂起,新的事务被创建,直到方法结束,新事务才结束,原先的事务才会恢复执行. |
| NEVER             | 声明方法绝对不能在事务范围内执行,如果方法在某个事务范围内执行,容器就抛异常.只有没关联到事务,才正常执行. |
| NESTED            | 如果一个活动的事务存在,则运行在一个嵌套的事务中.如果没有活动的事务,则按REQUIRED属性执行.它使用了一个单独的事务, 这个事务拥有多个可以回滚的保证点.内部事务回滚不会对外部事务造成影响, 它只对DataSourceTransactionManager 事务管理器起效. |



#### 事务隔离级别

**简述**：隔离级别定义一个事务可能受其他并发事务活动活动影响的程度。另一种考虑一个事务的隔离级别的方式，是把它想象为那个事务对于事物处理数据的自私程度。



- 当多个线程同时修改某个变量时，若未采取任何隔离措施，那么就可能出现丢失更新：每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。 　**任何一种事务都不允许丢失更新的发生**



##### 事务并发带来的问题

- 多个事务同时运行可能导致以下问题的发生

| 事务产生的问题 | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| 丢失更新       | 当多个事务同时修改某个变量时，若未采取任何隔离措施，那么就可能出现丢失更新：每个事务都不知道其它事务做出的更新，导致更新丢失 |
| 脏读           | 一个事务读到另一个事务未提交的更新数据                       |
| 不可重复读     | 在同一个事务中,多次读取同一数据,返回的结果有所不同. 换句话说就是,后续读取可以读到另一个事务已提交的更新数据. |
| 幻读           | 一个事务读取到另一个事务已提交的insert数据.                  |



##### 五种事务隔离级别

- spring事务有五种隔离级别，使用时通过**@Transactional(isolation=Isolation.DEFAULT)选择

```java
public enum Isolation {
    DEFAULT(-1),
    READ_UNCOMMITTED(1),
    READ_COMMITTED(2),
    REPEATABLE_READ(4),
    SERIALIZABLE(8);

    ...
}
```



#### spring事务传播行为的具体解释

- Required：默认的事务传播行为，表示必须有逻辑事务，否则新建一个事务，使用PROPAGATION_REQUIRED指定，表示如果当前存在一个逻辑事务，则加入该逻辑事务，否则将新建一个逻辑事务：

- RequiresNew：创建新的逻辑事务，使用PROPAGATION_REQUIRES_NEW指定，表示每次都创建新的逻辑事务（物理事务也是不同的）因此外部事务可以不受内部事务回滚状态的影响独立提交或者回滚。

- Supports：支持当前事务，使用PROPAGATION_SUPPORTS指定，指如果当前存在逻辑事务，就加入到该逻辑事务，如果当前没有逻辑事务，就以非事务方式执行。

- NotSupported：不支持事务，如果当前存在事务则暂停该事务，使用PROPAGATION_NOT_SUPPORTED指定，即以非事务方式执行，如果当前存在逻辑事务，就把当前事务暂停，以非事务方式执行。

- Mandatory：使用PROPAGATION_MANDATORY指定，如果当前有事务，使用当前事务执行，如果当前没有事务，则抛出异常（IllegalTransactionStateException）。

- Never：不支持事务，如果当前存在是事务则抛出IllegalTransactionStateException异常，使用PROPAGATION_NEVER指定。

- Nested：嵌套事务支持，使用PROPAGATION_NESTED指定，如果当前存在事务，则在嵌套事务内执行，如果当前不存在事务，则创建一个新的事务，嵌套事务使用数据库中的保存点来实现，即嵌套事务回滚不影响外部事务，但外部事务回滚将导致嵌套事务回滚。



- Nested和RequiresNew的区别： 
  RequiresNew每次都创建新的独立的物理事务，而Nested只有一个物理事务；
  Nested嵌套事务回滚或提交不会导致外部事务回滚或提交，但外部事务回滚将导致嵌套事务回滚，而 RequiresNew由于都是全新的事务，所以之间是无关联的；
  Nested使用JDBC 3的保存点实现，即如果使用低版本驱动将导致不支持嵌套事务。
      实际应用中一般使用默认的事务传播行为，偶尔会用到RequiresNew和Nested方式。