### hashmap插入值



#### put过程

1. 调用put方法插入键值对，计算key对应的hash，调用putval方法
2. putval方法进行实际的插入操作
3. 判断表（table属性）是否为空表，是则调用resize()方法进行表的初始化
4. 用表长和hash值进行按位与得到key对应的node p，（实际上这个按位与和用hash对表长进行取余的结果是一样的，但是位运算要快的多，这也是为什么表长（size）一定要为2的幂，否则不能通过按位与进行取余操作），判断该节点是否为空，是就根据key-value创建一个node节点
5. 比较节点p hash值和key值（使用等值比较和equals比较），相等替换p节点的value值；
6. 若节点p与key匹配不成功，判断节点p是否为树节点，是则调用putTreeVal方法进行key-value的插入，
7. 若节点p hash值与key值匹配不成功且不为树节点，遍历链表，知道找到匹配的节点或在链表尾部插入新节点，插入新节点后，若链表长度大于等于8，该链表转换为红黑树。
8. modCount值加一，若此时hashmap正在被遍历，则触发fall-fail
9. 判断需不需要扩容



##### 链表转化为红黑树的过程

hashmap在插入值成功后会进行链表长度（put会将新节点放在最后面，这过程中会记录链表长度）与树化阈值的比较，如果大于等于8就调用treeifyBin方法将当前节点转化为树节点（树节点是Node节点的派生类，可以直接替换），转化过程：

1. 判断table的容量是否小于表的最小树容量（64），小于则进行扩容并重新散列
2. 先在TreeifyBin中将这条链表上的所有节点转化为树节点，此时该链表为由树节点组成的双向链表
3. 取得table[index]也就是头节点调用treeify方法
4. 在treeify中，进行双重循环：
   1. 外层循环遍历链表，逐个将节点插入到红黑树中（第一个节点会直接设置为root节点，而不会进入内循环）；
   2. 内层循环：
      1. 先取根节点作为比较节点进行比较：先根据hash值划分左右，hash值相等就使用compareTo比较（这里会比较key的类型，类型不同的插入左子树，compareTo比较相等的会进行identityHashCode的比较再划分左右，identityHashCode相等的也划分左子树）划分左右
      2. 根据上面的划分找左右子树，为空就直接插入，并将插入节点的父节点设置为比较节点；否则将左右子树作为比较节点，进行循环
      3. 插入成功后调用balanceInsertion方法进行红黑树的变色和旋转，并将返回的节点作为根节点；退出此次内循环



#### HashMap扩容过程

- HashMap采用高低链的方式进行扩容，因为新数组的长度为原数组两倍，所以当前某的下标处的节点在新节点的位置要不就是原下标，要不就是原下标位置加上原数组的长度的位置，所以可以不用进行重新hash，只需要再对原数组长度进行与运算，得到当前节点的hash值是节点长度的奇数倍还是偶数倍就可以了，奇数倍的放高链位，偶数倍的放低链位，遍历完后再直接将高低链位移到新数组的相应位置



##### 红黑树的平衡过程





#### 红黑树插入值



#### 并发使用hashmap产生的问题

- 一个线程迭代时，另一个线程进行插入或删除操作，导致modCount不一致而fall-fail
- jdk1.7扩容时链表可能产生环，而尾插法不会改变原元素的next指向，所以不会出现环
- 多线程put可能导致元素丢失
- put非null元素结果get为null





#### 源码解析

```java
```

