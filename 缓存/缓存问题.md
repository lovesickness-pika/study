### 缓存三大问题

#### 缓存穿透

##### 描述

- 缓存穿透是指查询一个一定不存在的数据，因为这个数据在缓存中一定不存在，那么就会直接去数据库查询该数据，没有缓存层的保护，这种查询可能会被人恶意使用，大量访问数据库，可能会导致数据库瘫痪等问题

##### 解决方案

- 如果redis可以缓存全部的数据库中的数据，那么完全可以不去数据库中查数据，自然没有缓存穿透的问题；但实际情况是缓存没办法缓存掉所有的数据，更多的是缓存热点数据，那么访问数据库是避免不了的，那么思路应该是避免频繁的让某个不存在的值访问数据库，常用的解决方案有**bloom filter**和**空值缓存**等 



##### 空值缓存

- 每次数据库中取得为空的值，在缓存层缓存份空值，并设定较短的过期时间，这样当该值再次访问时，会从缓存层取得空值而不会访问到数据库层；但使用空值缓存阻止不了使用随机值进行攻击的方式，甚至会导致缓存层的热点数据被挤出，当然，可以使用类似于innodb缓存池使用的LRU队列使用的midpoint方式来防止，但还是会导致反效果 



##### bloom filter

- 就是使用bitmap来保存所有在数据库中所有存在的数据，当请求发生时，会先通过bitmap来判断该数据是否存在





#### 缓存雪崩

##### 描述

- 一般缓存都有设置有效期，当大量的缓存在较短的时间内同时失效，导致很多请求被发送到数据库，导致数据库瘫痪等问题

##### 解决方案

- 可以使用一定范围的随机值设置有效期，使缓存的有效期在可接受的范围分布而不是集中在一个时候；或者在缓存与数据库之间加个锁或semaphore这样的工具类来控制访问数据库的数量，但是会降低一定的效率，可以在获取锁之前再进行一次缓存确认，算是一点点优化吧





### 缓存击穿

##### 描述

- 缓存是为了缓解数据库的工作量而生，其实这几个缓存问题都是因为缓存层没有拦截到请求，导致数据库在短时间内被大量连接，缓存击穿则是比较极端的情况，某个数据特别热点，在同一时间可能会出现几十万的访问这种，如果缓存层没有拦截到，那么光这一条数据就足以使服务器瘫痪

##### 解决方案

- 如果是预售商品这种，因为此数据压根就没有被访问过，所以可能在缓存中就没有，这种情况应该进行缓存预热
- 如果是已经在缓存中的热点数据，可能因为缓存过期的缘故导致导致请求到达数据库，这种应该设置缓存永不过期或者加锁

