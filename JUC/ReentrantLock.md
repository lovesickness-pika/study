### ReentrantLock

- 公平锁与非公平锁有什么不同？
  - 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
    - 优点：保证了请求资源的顺序，并且不会出现饿死的线程。
    - 缺点：吞吐量会下降很多，需要进行频繁的上下文切换。

  - 非公平锁：多个线程去获取锁的时候，会直接去尝试获取锁，未获取到才会进入同步队列。
    - 优点：减少线程的上下文切换，系统的吞吐量更大。
    - 缺点：在并发较高的情况下可能导致等待队列中的线程饿死





#### 可重入锁的加锁过程

##### 非公平锁的加锁过程

1. 线程会先尝试一次直接获取锁，即CAS修改state的值，修改成功则取得锁，否则进入acquire方法
2. 否则进入tryAcquire方法再一次尝试获取锁，获取不成功再判断当前线程是否已持有锁，是则代表是在进行锁重入，持有锁数加1
3. 尝试获取锁失败则进入addWaiter方法将当前线程加入同步队列，在addwaiter中会调用enq方法将当前线程加入阻塞队列
4. 进入acquireQueue方法，在这个方法里，线程会循环的尝试获取锁，并进入阻塞状态，等待前一个节点的唤醒：
   1. 线程会判断前一个节点是否为头结点，是则尝试获取锁，否则通过shouldParkAfterFailedAcquire方法判断是否要进入阻塞
   2. 需要进入阻塞会调用parkAndCheckInterrupt进入阻塞，等待其它线程唤醒，并在被唤醒后通过Thread.interrupted方法判断在阻塞时是否被中断，已经被中断则将中断标志位设置为true，在获取锁之后立刻调用selfInterrupt方法中断当前线程





##### 公平锁的加锁过程

- 公平锁的加锁过程与非公平锁的加锁过程很类似，除了在尝试加锁前会通过hasQueuedPredecessors方法判断队列中是否有值，有其它线程就加入队列而不会直接去尝试获取锁



#### 可重入锁的解锁过程

- 可重入锁每次解锁会使state的值减一，直到减到0表示当前线程已不再持有锁后调用unparkSuccessor方法唤醒下一节点





