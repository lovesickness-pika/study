##### 锁的一些特性

- 可重入性：记录线程获取锁的次数，在退出代码块时，计数器减一，直到计数器清零
- 不可中断性：一个线程获取锁之后，其他线程只能等待锁的释放，不可中断

##### 偏向锁

- jdk1.6后默认启动，可以通过该参数关闭：-XX:-UseBiasedLocking

- 默认程序启动后有4000ms的延迟，之后进入可偏向未偏向状态（匿名偏向），可以通过该参数修改延迟：-XX:BiasedLockingStartupDelay

- 偏向锁启用后，Mark Word中的偏向锁标志位为1，并用54bit记录了当前对象偏向的线程的id

- 关于mark word中存储信息的问题
  - 对象头在无锁状态下（001），mark word 中可储存对象的Identity hash code，若对象已计算过Identity hash code,对象将无法进入偏向锁状态；
  - 对象已进入偏向锁，若需要计算Identity hash code，则会发生偏向锁的撤销，然后锁膨胀为轻量级锁或重量级锁；Identity hash code是未被覆写java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。
  - 轻量级锁的实现中，会通过线程栈帧的锁记录存储Displaced Mark Word；重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。
  
- 偏向锁撤销：当发生锁竞争或计算Identity hash code时，需要等到safe point，将偏向锁升级为重量级锁或轻量级锁，这会消耗一定的性能

- 当一个类的对象总是因为锁竞争引起锁膨胀，导致了大量的偏向锁撤销操作，明显会导致性能下降，此时需要进行偏向锁的批量重偏向或批量撤销，类元数据类有个属性记录了锁撤销次数

  - 此参数决定了何时批量重偏向，默认为20：-XX:BiasedLockingBulkRebiasThreshold
  - 此参数决定了何时批量撤销，默认为40：-XX:BiasedLockingBulkRevokeThreshold
  - 此参数为重置偏向锁撤销次数的时间间隔,默认25000：-XX:BiasedLockingDecayTime

- 偏向锁逻辑：

  1. 线程A第一次访问同步块时，先检测对象头Mark Word中的标志位是否为01，依此判断此时对象锁是否处于无锁状态或者偏向锁状态（匿名偏向锁）；

  

  2. 然后判断偏向锁标志位是否为1，如果不是，则进入轻量级锁逻辑（使用CAS竞争锁），如果是，则进入下一步流程；

  3. 判断是偏向锁时，检查对象头Mark Word中记录的Thread Id是否是当前线程ID，如果是，则表明当前线程已经获得对象锁，以后该线程进入同步块时，不需要CAS进行加锁，只会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，用来统计重入的次数（如图为当对象所处于偏向锁时，当前线程重入3次，线程栈帧中Lock Record记录）。

  -  偏向锁重入,退出同步块释放偏向锁时，则依次删除对应Lock Record，但是不会修改对象头中的Thread Id；

  - 注：偏向锁撤销是指在获取偏向锁的过程中因不满足条件导致要将锁对象改为非偏向锁状态，而偏向锁释放是指退出同步块时的过程。


  4. 如果对象头Mark Word中Thread Id不是当前线程ID，则进行CAS操作，企图将当前线程ID替换进Mark Word。如果当前对象锁状态处于匿名偏向锁状态（可偏向未锁定），则会替换成功（将Mark Word中的Thread id由匿名0改成当前线程ID，在当前线程栈中找到内存地址最高的可用Lock Record，将线程ID存入），获取到锁，执行同步代码块；

  5. 如果对象锁已经被其他线程占用，则会替换失败，开始进行偏向锁撤销，这也是偏向锁的特点，一旦出现线程竞争，就会撤销偏向锁；

  6. 偏向锁的撤销需要等待全局安全点（safe point，代表了一个状态，在该状态下所有线程都是暂停的）,暂停持有偏向锁的线程，检查持有偏向锁的线程状态（遍历当前JVM的所有线程，如果能找到，则说明偏向的线程还存活），如果线程还存活，则检查线程是否在执行同步代码块中的代码，如果是，则升级为轻量级锁，进行CAS竞争锁；

  - 注：每次进入同步块（即执行monitorenter）的时候都会以从高往低的顺序在栈中找到第一个可用的Lock Record，并设置偏向线程ID；每次解锁（即执行monitorexit）的时候都会从最低的一个Lock Record移除。所以如果能找到对应的Lock Record说明偏向的线程还在执行同步代码块中的代码。

7. 如果持有偏向锁的线程未存活，或者持有偏向锁的线程未在执行同步代码块中的代码，则进行校验是否允许重偏向，如果不允许重偏向，则撤销偏向锁，将Mark Word设置为无锁状态（未锁定不可偏向状态），然后升级为轻量级锁，进行CAS竞争锁；
8. 如果允许重偏向，设置为匿名偏向锁状态,CAS将偏向锁重新指向线程A（在对象头和线程栈帧的锁记录中存储当前线程ID）；

  9. 唤醒暂停的线程，从安全点继续执行代码。

##### 轻量级锁

如果说偏向锁是只允许一个线程获得锁，那么轻量级锁就是允许多个线程获得锁，但是只允许他们顺序拿锁，不允许出现竞争，也就是拿锁失败的情况，轻量级锁的步骤如下：

1）线程1在执行同步代码块之前，JVM会先在当前线程的栈帧中创建一个空间用来存储锁记录，然后再把对象头中的Mark Word复制到该锁记录中，官方称之为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word 替换为指向锁记录的指针。如果成功，则获得锁，进入步骤3）。如果失败执行步骤2）

2）线程自旋，自旋成功则获得锁，进入步骤3）。自旋失败，则膨胀成为重量级锁，并把锁标志位变为10，线程阻塞进入步骤3）

3）锁的持有线程执行同步代码，执行完CAS替换Mark Word成功释放锁，如果CAS成功则流程结束，CAS失败执行步骤4）

4）CAS执行失败说明期间有线程尝试获得锁并自旋失败，轻量级锁升级为了重量级锁，此时释放锁之后，还要唤醒等待的线程

##### 公平锁与非公平锁

- 公平锁与非公平锁有什么不同？

  - 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
    - 优点：保证了请求资源的顺序，并且不会出现饿死的线程。
    - 缺点：吞吐量会下降很多，需要进行频繁的上下文切换。

  - 非公平锁：多个线程去获取锁的时候，会直接去尝试获取锁，未获取到才会进入同步队列。
    - 优点：减少线程的上下文切换，系统的吞吐量更大。
    - 缺点：在并发较高的情况下可能导致等待队列中的线程饿死

