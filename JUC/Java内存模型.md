### Java内存



##### CPU三级缓存

- 由于CPU速度与内存速度有着较大差距，所以在CPU与内存之间有着三级缓存。
- 三级缓存（包括L1一级缓存、L2二级缓存、L3三级缓存）都是集成在CPU内的缓存，它们的作用都是作为CPU与主内存之间的高速数据缓冲区，L1最靠近CPU核心；L2其次；L3再次。运行速度方面：L1最快、L2次快、L3最慢；容量大小方面：L1最小、L2较大、L3最大。CPU会先在最快的L1中寻找需要的数据，找不到再去找次快的L2，还找不到再去找L3，L3都没有那就只能去内存找了。



##### 缓存一致性协议

intel的**MESI**：
由于每个处理器都含有私有的高速缓存，在对缓存中数据进行更新后，其他处理器中所含有的该共享变量的缓存如果被处理器进行读操作，就会出现错误。有些计算机采用LOCK#信号对总线进行锁定，当一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞，那么该处理器就能独自共享内存。然而总线锁定的开销太大，在之后的计算机中一般都采用“缓存锁定”的方式实现。
MESI是代表了缓存数据的四种状态的首字母，分别是Modified、Exclusive、Shared、Invalid）

- M(Modified)：被修改的。处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中。

- E(Exclusive)：独占的。处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致。

- S(Shared)：共享的。处于这一状态的数据在多个CPU中都有缓存，且与内存一致。

- I(Invalid)：要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。

  在缓存行中有这四种状态的基础上，通过“嗅探”技术完成以下功能：【嗅探技术能够嗅探其他处理器访问主内存和它们的内部缓存】

- 一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU。

- 一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I。

- 一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S。

- 只有E和M可以进行写操作而且不需要额外操作，如果想对S状态的缓存字段进行写操作，那必须先发送一个RFO(Request-For-Ownership)广播，该广播可以让其他CPU的缓存中的相同数据的字段实效，即变成I状态。
通过以上机制可以使得处理器在每次读写操作都是原子的，并且每次读到的数据都是最新的。



#### JMM 

- JMM作为虚拟机规范的一部分内容，规定了：每个线程都有自己的工作内存，工作内存中的“共享变量”只是主存共享变量在本地的私有拷贝，对数据的操作都只能在工作内存中进行，更新之后需要同步回主存，而不同的线程之间无法访问其它线程工作内存里的变量，线程之间值的传递必须通过主存来完成等等。





##### as-if-serial

- 不管怎么重排序，程序的执行结果不能改变，保证最终一致性



##### happens-before

- happens-before用来指定两个操作之间的顺序关系，JMM对开发人员保证如果A happens-before B，那么A就是在B之前；同时JMM又允许编译器和处理器在不改变最终一致性的前提下对语句的重排序
- happens-before规则：
  1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任何后续操作
  2. 监视器锁规则：对于一个锁的解锁，happens-before于随后对这个线程的加锁
  3. volatile变量规则：对于一个volatile域的写，happens-before于任何后续对于这个volatile域的读
  4. 传递性：如果A happens-before B， B happens-before C， 那么 A happens-before C;
  5. start规则：如果线程AstartB，那么A线程的start操作 happens-before于线程B中的任何操作
  6. join规则，如果在线程A中执行ThreadB.join()并成功返回，那么线程B中的任何操作happens-before于线程A调用ThreadB.join操作的返回



#### volatile关键字

##### volatile为什么可以保证可见性，为什么不能保证原子性



#### 对final域重排序的规则

- 写final域重排序规则禁止把final域的写重排序到构造方法之外；编译器会在final域的写之后，构造函数返回之前，插入一个StroreStore屏障，这个屏障禁止处理器 把final的写重排序到构造函数之外

- 读final域重排序的规则为，在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM禁止重排序这两个操作。编译器会在读final域的操作前面插入一个LoadLoad屏障

