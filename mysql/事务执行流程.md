###  事务执行流程

1. 启动事务，set autocommit = 0； 或者显示启动一个事务 begin或者start transaction
2. 启动事务后并不会为当前事务分配事务id等，而是延迟到第一次操作，第一次执行操作后，会为当前事务分配一个事务id，并生成一个readview，这个readview是实现事务隔离的关键，readview中保存了
   - m_ids，当前正在执行的所有事务
   - min_trx_id，当前正在执行的所有事务的最小事务id
   - max_trx_id，下一个分配的id
   - creator_trx_id，创建这个读视图的事务id
3. 事务更新某条数据时，会先获取这条数据的行锁，然后将更新前的数据写入undo log，并构建指向该 undo log的指针DB_POOL_PTR，并产生redo log
4. 当再次访问某条数据的时候，就会通过这个数据行的隐藏字段DB_TRX_ID与当前事务的读视图，然后再根据不同的事务隔离级别，就可以访问到数据的不同版本，举个示例吧：
   1. 有t1，t2，t3三个事务，事务t1修改了id=1这一列并且提交了，那么这一列的DB_TRX_ID就是t1的事务id，然后t2，t3依次开启，并依次获取读视图，那么因为这两个事务的min_trx_id是大于id=1这一列的DB_TRX_ID，所以这两个事务都对t1之前做的修改可见，可以读到最新版本的数据，然后t2再去修改id=1这一列，这个时候会获取这一列的行锁，t3修改不了，但是可以读，innodb使用mvcc实现了无锁读，这个时候就会根据不同的隔离级别有不同的反应：如果是RU级别，不会去判断行版本的可见性，直接获取当前行的记录，也就是最新的记录；如果是RC级别，会生成一个新的readview，然后进行判断行记录的DB_TRX_ID，这个DB_TRX_ID小于min_trx_id是可见的，等于当前事务id也是可见的，大于等于max_trx_id就是不可见的，在min_trx_id和max_trx_id之间，就用二分查询看它在是否在活跃列表中，在则不可见，否则可见，这也就是为什么提交了的事务在RC级别是可见的；然后如果是RR级别就根据之前的readview进行可见性判断；如果不可见就根据DB_ROOL_PTR向上一个版本的数据进行可见性判断
5. 事务提交，二阶段提交redo log和bin log





##### 二阶段提交

1. 设置状态为undo state = trx_undo_prepared
2. 刷新redo log缓冲到磁盘
3. 进入commit阶段
4. 将事务产生的binlog写入文件刷新到磁盘
5. 设置undo页的状态为

##### 二阶段组提交


