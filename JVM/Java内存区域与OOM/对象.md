### HotSpot对象



#### 对象的创建

- 当虚拟机执行到字节码new指令时：
  1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个类是否已被加载、解析和初始化过，如果没有，那么要执行类加载过程
  2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存；对象所需内存在类加载完成后是可以完全确定的
  3. 内存分配完成后，虚拟机必须将分配到的内存空间都初始化为零值，如果使用了TLAB，这一项任务可以提前至TLAB分配时顺便进行
  4. 将内存空间初始化零值后，Java虚拟机会对对象进行必要的设置，为对象头设置一些信息
  5. 调用构造函数，即Class文件中的<init>()方法



#### 对象内存分配

- 为对象分配内存实际上就是从java堆分配一块空间

##### 对象内存分配的方法

- 如果java内存是绝对规整的，那么可以采用**指针**碰撞方法
- 如果java内存不规整，那么虚拟机必须维护一个**空闲列表**

- java虚拟机根据内存是否规整选择分配方式，而java内存是否规整与垃圾收集器是否带有空间压缩整理的能力决定；使用Serial、ParNew等带压缩整理过程的收集器时，可以使用指针碰撞，而CMS这种基于清除算法的收集器，理论上只能采用较为复杂的空闲列表

##### 对象内存分配的并发问题

- CAS加重试解决
- 为每个线程预先分配一块内存，叫做本地线程分配缓存TLAB（Thread Local Allocation Buffer），空间不够再使用CAS扩容



##### 对象内存布局

- markword （标记字段）8字节
  - 根据对象的状态复用此空间，运行期间mark word内的数据随锁标志位的变化而变化
  - 锁信息
  - gc标记信息
  - hashcode
- klass pointer（类型指针）8字节，指向类元数据的指针
- data （实例数据）
- padding （对齐填充），对象起始地址为8字节的整数倍

| 存储内容                           | 标志位 | 状态       |
| ---------------------------------- | ------ | ---------- |
| 对象哈希码、对象分代年龄           | 01     | 未锁定     |
| 指向锁记录的指针                   | 00     | 轻量级锁定 |
| 指向重量级锁的指针                 | 10     | 重量级锁定 |
| 空，不记录信息                     | 11     | GC标记     |
| 偏向锁ID、偏向时间戳、对象分代年龄 | 01     | 偏向       |

**面试题**：空的对象占用内存大小：32位操作系统8个字节，64位操作系统16个字节

- 对象占用内存的大小为8字节的整数倍



#### 对象的访问定位

- 通过栈上的reference数据来操作堆上的数据

##### 对象的访问方式

对象的访问方式主要有句柄访问和直接指针访问两种

- 如果使用句柄访问，java堆可能会划分一块内存作为句柄池，reference中存放对象的句柄地址，而句柄中分别存放对象实例数据和对象类型信息各自的地址
- 直接指针访问要求java堆中的对象的内存布局如何存储访问类型数据的信息，reference中存储的直接是对象地址

##### 句柄访问和直接指针访问的优缺点

- 句柄访问最大的好处是reference的稳定，对象移动时，只需要修改句柄，不需要修改reference
- 直接引用指针最大的好处是快，节省了一次指针定位的开销

**HotSpot**使用的是直接引用指针，如果使用了Shenandoal收集器的话也会有一次的额外转发