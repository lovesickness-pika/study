### Java运行时数据区

- 程序计数器、虚拟机栈、本地方法栈、堆、方法区



- 线程私有：虚拟机栈、本地方法栈、程序计数器
- 线程共享：堆、方法区



#### 程序计数器

- 程序计数器是一块较小的内存区域，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器
- 程序计数器是java运行时区域唯一不会报OOM的区域



#### Java虚拟机栈

- java虚拟机栈的生命周期与线程相同
- 虚拟机栈描述的是Java方法执行时的线程内存模型



#### 本地方法栈

- 本地方法栈起到的作用与Java虚拟机栈类似，不同的是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈只为本地方法服务



#### Java堆

- Java堆是被所有线程共享的一块区域，在虚拟机启动时创建
- Java堆存在的唯一作用是存放对象实例
- Java堆是垃圾收集管理器管理的内存区域
- 在java堆中可以划分出多个线程私有的分配缓冲区
- java堆可固定大小也可以扩展，目前主流的java虚拟机都是可扩展的



#### 方法区

- 方法区是线程共享的
- 方法区存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据

- 方法区理论上来说是堆的逻辑组成部分，方法区在jdk8之前是使用的永久代来实现，在jdk8后使用元空间实现，这两种方式都是对java虚拟机规范中方法区的实现，不同的是永久代是使用的虚拟机内存，而元空间使用的是本地内存，并且元空间仅存放类的元信息，将静态变量和常量池是存储在堆中了

#### 运行时常量池

- 运行池常量池是方法区的一部分
- Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用来存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。
- 运行期也可以将新的常量放入池中



#### 直接内存

- 直接内存并不属于java运行时数据区
- JDK1.4引入了NIO，引入了一种基于通道与缓冲区的IO方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了Java堆和Native堆中来回复制数据
