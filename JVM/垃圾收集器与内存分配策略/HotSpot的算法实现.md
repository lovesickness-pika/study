### HotSpot的算法实现



#### 根节点枚举

- 所有收集器在根节点枚举这一步骤时是必须暂停用户线程的，也就是根节点的枚举在一个能保障一致性的快照中才得以进行，也就是在根节点枚举过程中根节点集合的对象的引用关系不能发生变化
- 目前主流的Java虚拟机使用的都是准确式垃圾收集，虚拟机在用户停顿后不需要检查完所有执行上下文和全局的引用位置，虚拟机有办法直接得到哪些地方存放着对象引用；在HotSpot中通过OopMap数据结构在达到这个目的。类加载完成后，Hotspot就会把对象什么偏移量上是什么类型的数据计算出来，在即时编译的过程中，也会在特定的位置记录栈中和寄存器里哪些位置是引用。GC开始的时候，就通过OopMap这样的一个映射表知道，在对象内的什么偏移量上是什么类型的数据，而且特定的位置记录下栈和寄存器中哪些位置是引用。

- 保守式GC与准确式GC



#### 安全点

- HotSpot使用了OopMap来进行准确式GC，但这需要额外维护这张表，如果每条指令都要修改OopMap，那么代价会非常大，那还不如使用句柄访问对象，而且垃圾收集也不是需要随时进行；
- HotSpot使用安全点的方式来减少这种负担，即只是在“特定的位置”记录这些信息

##### 安全点的选择

- 安全点的选择以是否能让程序长时间执行的特征为标准进行的，长时间的特征表现为指令序列的复用，例如：方法调用、循环跳转、异常跳转等

##### 线程如何到达安全点

- 抢占式中断和主动式中断：抢占式中断是先中断，再恢复再中断；主动式中断是程序运行到安全点自动中断
- HotSpot使用内存保护陷阱的方式把轮询操作精简至只有一条汇编的程度

#### 安全区域

- 当线程处于Sleep或Blocked状态时，无法响应中断进入安全点，所以引入了安全区域
- 安全区域指能够确保在某一段代码片段中，引用关系不会发生变化，因此，在这个区域中任何地方都是安全的
- 线程要离开安全区域前，要先检查虚拟机是否已经完成了根节点枚举，如果还未完成，要待在安全区等待完成



#### 解决跨代引用问题：记忆表与卡表

- 垃圾收集器建立了名为记忆集的数据结构，以避免回收新生代时将整个老年代全部纳入回收范围
- 垃圾收集器只需要通过记忆集判断某一块非收集区域是否存在指向收集区域的指针就可以了，那么就可以使用更低粒度的实现方式
- 目前最常用的是使用卡粒度，使用卡表去实现记忆集

##### 卡表

- 卡表最简单的形式可以只是一个字节数组，HotSpot使用的就是字节数组
- 字节数组的每个元素对应一个固定大小的内存块（HotSpot中时512个字节）叫做卡页，如果这个卡页中存在一个或多个跨代引用，就将对应卡表标识为1，垃圾收集发生时，筛选出变脏的元素就能找到那些卡页内存块包含跨代指针，就可以将它们加入扫描



#### 写屏障

- 在有其它分代区域中对象引用了本区域对象时，卡表元素变脏，所以变脏的时间点原则上是发生在引用类型字段赋值那一刻
- HotSpot使用写屏障来维护卡表状态，即对引用类型的AOP切面，只有G1用到了写后屏障，其它收集器都只用到了写前屏障

##### 卡表的伪共享问题

- 伪共享问题：现代中央处理器的缓存系统中是以缓存为单位存储的，当多线程修改互相爱能独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响而导致性能下降36
- 避免方式：不采用无条件的写前屏障，而是先检查卡表标记，只有当卡表元素未被标记过才将其标记为变脏



#### 并发的可达性分析

- 使用三个颜色来表示对象的访问状态

现代收集器和用户线程大部分都是并发工作的，那么如何保证可达性标记的正确性？

##### “对象消失”问题

- 当且仅当这两个条件满足时，会产生“对象消失”问题
  - 赋值器插入了一条或多条从黑色对象到白色对象的新引用
  - 赋值器删除了全部从灰色到该白色对象的直接或间接引用
- 解决方法：增量更新和原始快照

##### 增量更新与原始快照

- 增量更新破坏第一个条件，当黑色对象有新的到白色对象的引用时，会将这些黑色对象记录下来，再扫描一次，可以理解为变回了灰色对象
- 原始快照破坏第二个条件，当有灰色对象要删除指向白色对象的引用时，就将这些记录过的引用关系中的灰色对象做为根，再扫描一次，即无论有没有删除，都按照之前的引用关系进行搜索
- 无论对引用关系记录的删除和插入，都是通过写屏障实现的
- CMS是基于增量更新做并发标记，G1和Shenandoah是用原始快照来实现的

- 增量更新与原始快照的优缺点：原始快照需要使用写前屏障来跟踪并发时的指针变化情况，相比于增量更新算法，原始快照可以减少并发标记和重新标记阶段的消耗，减少重新标记阶段的停顿时间，但是在并发标记阶段会产生更多的消耗