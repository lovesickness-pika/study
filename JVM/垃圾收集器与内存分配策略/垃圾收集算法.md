### 垃圾收集算法



#### 分代收集理论

- 垃圾分代收集理论建立在两个分代假说上：

##### 弱分代假说

- 绝大对象都是朝生夕灭的

##### 强分代假说

- 熬过越多次垃圾收集的对象越难以消亡



##### 跨代引用假说

- 跨代引用相对于同代引用来说仅占极少数



#### GC分类

- 部分收集（Partial GC）：目标不是完整收集整个Java堆的垃圾收集
  - 新生代收集（Minor GC/Young GC）：只针对新生代的收集
  - 老年代收集（Major GC/Old GC）：指目标只是老年代的收集。目前只有CMS收集器有单独收集老年代的行为
  - 混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集
- 整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集



### GC算法

#### 标记-清除算法

- 统一标记需要回收（或存活）的对象，一次性回收掉所有被标记（或未被标记）的对象

##### 缺点

- 执行效率不稳定，如果java堆中存在大量需要被回收的对象，那么就会导致标记和清除两个过程的执行效率随对象数量的增加而降低
- 内存空间碎片化，可能导致当程序运行过程中需要分配较大对象时无法找到足够的连续内存而导致提前的另一次垃圾收集



#### 标记-复制算法

- 将存活的对象移到另一块空闲内存上，一次回收掉剩下的需要回收的对象

##### 优点

- 对象内存空间分配简单，只需要移动栈顶指针即可

##### 缺点

- 浪费了一部分可用内存
- 对象存活率较高时要进行较多的复制操作



##### 标记-复制算法的优化 Appel式回收

- 将新生代分为一块较大的Eden空间和两块较小的Survivor，每次分配内存只使用一块Eden空间和一块Survivor空间，发生垃圾收集时，将仍然存活的对象复制到另一块Survivor空间上，再一次回收掉这块Eden空间和Survivor空间；如果这块Survivor空间不够时，需要依赖其它内存区域进行分配担保
- Eden：Survivor=8:1
- 目前HotSpot虚拟机的Serial、ParNew等新生代收集器均采用的这种策略来设计新生代的内存布局



#### 标记-整理算法

- 标记过程与标记清除算法一样，但后续步骤是先让存活对象向内存空间一端移动，再清除掉边界以外的内存

##### 优点

- 内存空间的碎片化问题得到解决

##### 缺点

- 移动存活对象并更新所有引用这些对象的地方是一种极为负重的操作，而且对象移动操作必须全程暂停用户应用程序