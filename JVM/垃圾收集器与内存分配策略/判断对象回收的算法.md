### 判断对象回收的算法

#### 引用计数算法

- 通过对象被引用的次数来判断对象是否需要回收
- 引用计数算法比较简单，但有许多特殊情况需要考虑，例如相互循环引用



#### 可达性分析算法

- 目前主流的垃圾收集器都是使用可达性分析算法来判断对象是否存活
- 可达性分析算法通过一系列叫做“GC Roots”的根对象作为起始节点集，如果某个对象到GC Roots间没有引用链相连，或者说GC Roots到这个对象不可达时，则此对象是不可再被使用的



#####  Roots

- 虚拟机栈中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈JNI引用的对象
- 所有被同步锁持有的对象
- Java虚拟机的内部引用



#### 四种引用

##### 强引用

- 普通的对象赋值就是强引用，GC不会回收强引用的对象。当内存空间不足时，GC宁愿报OOM异常也不会回收具有强引用的对象

##### 软引用

- 可以通过java.lang.ref.SoftReference使用软引用，GC回收机制会在内存不足时回收具有软引用的对象

##### 弱引用

- 可以用java.lang.ref.WeakReference实例来保存对一个Java对象的弱引用，被GC扫描到了的弱引用的对象，无论内存是否充足，都会被回收

##### 虚引用

- 虚引用并不会决定对象的生命周期。虚引用关联的唯一目的是使该对象被回收时得到一个系统通知，一个比较典型的引用场景便是堆外内存的回收。虚引用必须配合ReferenceQueue使用



#### finalize

- 对象的死亡要经过两次标记阶段：
  1. 对象没有与GC Roots相连接的引用链，会被标记为死亡
  2. 如果对象没有重写finalize()方法，或者对象的finalize()方法已经被虚拟机执行过一次，那么虚拟机将不会执行finalize方法，对象死亡
- 如果对象被判定为需要执行finalize方法，那么这个对象会被放置在一个F-Queue队列中，并由一条由虚拟机自动建立的低调度优先的Finalizer线程去执行，执行指对象的finalize方法有机会被执行，但虚拟机不会保证执行完



#### 方法区的回收

- 方法区需要回收的内容主要有废弃的常量和不再使用的类型
- 常量的回收比较简单，与对象一样，如果某个常量不再被引用，就可以回收
- 类型的回收需要满足三个条件才可能被回收：
  - 该类型的所有实例已经被回收
  - 加载该类的类加载器已经被回收
  - 该类对应的java.lang.Class对象没有在任何对方被引用