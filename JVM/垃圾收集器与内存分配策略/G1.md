### Garbage First

- Garbage First是一款面向局部收集的垃圾收集器，并且是基于Region的内存布局格式
- Garbage First的目的是实现可预测的停顿时间模型

- Garbage First从整体上看是基于“标记-整理”算法实现的，但是从细节上是基于“标记-复制”算法实现的

- Garbage First将堆内存划分为许多个Region区域，每个Region区域根据需要扮演新生代或老年代的角色，并使用Humongous区域用来存储大对象，这里的大对象指超过region区域大小一半

- Garbage First并不追求一次性将整个java堆清理干净，而是在允许的停顿时间模型内做到最大的吞吐量

#### G1垃圾收集器运行过程

##### 初始标记

- 与CMS一样，标记根节点枚举中能作为根节点的对象，这部分对象主要有被虚拟机栈与本地方法栈引用的对象，被静态属性量与常量引用的对象，被同步锁持有的对象，虚拟机内部的引用；这个阶段需要停顿用户线程

##### 并发标记

- 根据初始标记的对象进行可达性分析，找出所有被引用的对象，这个过程与用户线程并发执行；对象图扫描完之后，要重新处理SATB记录下的并发时有引用变动的对象

##### 最终标记

- 基于原始快照的方式再对发生过引用变动的对象进行可达性分析，防止对象消失问题，这个阶段也需要停顿用户线程

##### 筛选回收

- 更新Region的统计数据，对各个Region的回收价值和成本进行排序，再根据用户所期望的停顿时间模型来指定回收计划，这样可以在延迟可控的情况下尽量提高系统的吞吐量；这个阶段也是需要停顿用户线程的，停顿用户线程可以达到最大的收集效率



##### G1建立可停顿时间模型的关键

- G1建立可停顿时间模型的关键是将Region作为最小回收单元，并为每个region的回收价值进行跟踪并排序，这样就可以每次根据用户设置的允许的收集停顿时间去回收最大回收价值的region



##### G1的跨代引用问题





#### G1与CMS的比较

- G1内存占用与cpu消耗更高
- G1不会产生碎片空间的问题
- 小内存使用CMS会更好一点



