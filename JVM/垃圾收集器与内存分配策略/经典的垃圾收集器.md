### 垃圾收集器

#### Serial收集器

- 单线程工作的收集器，工作时使用一个线程完成垃圾收集工作，并暂停所有用户线程
- 额外内存消耗最小
- 对于单核处理器或核心数较少的处理器，由于Serial没有线程交互的开销，专心做垃圾收集可以获取最高的单线程收集效率
- serial是默认的客户端模式下的垃圾收集器，对于运行在客户端模式下的虚拟机来说是一个很好的选择
- 新生代采用复制算法，老年代采用整理算法

#### ParNew收集器

- Serial收集器的多线程版本，除了同时使用多个线程进行垃圾收集以外，其余的行为包括Serial收集器可用的参数、收集算法、Stop the World、对象分配规则、回收策略等都与Serial收集器完全一致
- 除了Serial以外，只有它能与CMS收集器配合工作
- ParNew收集器是激活CMS后的默认新生代收集器
- 默认开启的收集线程数与处理器核心数相等

#### Parallel Scavenge收集器

- 基于复制算法的新生代收集器，并行收集
- Parallel Scanvage的关注点是达到一个可控制的吞吐量。吞吐量指处理器用于运行用户代码的时间和处理器总消耗时间的比值
- 高吞吐量可以最高效率的利用处理器资源，尽快的完成程序的任务，主要适合在后台执行不需要太多交互的工作
- 自适应调节策略是Parallel Scanvage收集器区别于ParNew收集器的一个重要特性

#### Serial Old收集器

- Serial收集器的老年代版本，也是一个单线程收集器
- 使用标记-整理算法
- 供客户端模式下的HotSpot虚拟机使用
- 服务端模式下，JDK5以前与Parallel Scanvage配合使用，或者是作为CMS收集器发生失败时的预备方案，在并发收集发生Concurrent Mode Failure时使用

#### Parallel Old收集器

- Parallel Scanvage的老年代版本，支持多现程并发搜集
- 基于标记整理算法
- 在注重吞吐能力或处理器资源比较稀缺的场合，可以优先考虑Parallel Scanvage+Parallel Old收集器组合

#### CMS收集器

- CMS是一款以获取最短停顿时间为目标的收集器，适合用于注重响应速度的需求

- 基于标记清除算法，可能会因为碎片空间过多而导致的full gc
- 整个过程分四步，其中初始标记和重新标记要stop the world：
  1. 初始标记
  2. 并发标记
  3. 重新标记
  4. 并发清除
- 默认开启的回收线程数是（处理器核心数量+3）/4
- CMS收集器无法处理“浮动垃圾”，可能会出现“Concurrent Mode Failure”而导致另一次完全“stop the world”的Full GC产生。
- 在CMS的并发标记阶段和并发清除阶段产生的垃圾叫做浮动垃圾，CMS只能在下一次垃圾回收再回收这部分垃圾，必须预留一部分空间给用户线程使用

#### Garbage First 收集器

- G1开创了收集器面向局部收集的设计思路和基于Region的内存布局形式
- G1是一款面向服务端应用的垃圾收集器

##### Region

- G1开创了基于Region的堆内存布局，虽然G1也是遵循分代收集策略，但它不再坚持固定分区，而是把连续的Java堆划分成多个大小相等的独立区域（Region），根据需要去分配

- Region中有一类特殊的Humongous区域，专门又来存储大对象，G1认为只要某个对象超过了Region的一半就是大对象
- G1收集器之所以能建立可预测的停顿时间模型，是因为以Region作为单元回收的最小单位，即每次回收的内存空间都是Region大小的整数倍，这样可以有计划的避免在整个java堆中进行全区域的垃圾收集
- G1收集器去跟踪各个Region里面垃圾堆积的“价值”大小，价值即回收所获得空间大小及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户所允许的停顿时间去优先收集价值更高的Region
- G1的每个Region都有维护一个以哈希表为存储结构的记忆集，以此来解决跨代引用问题，这些记忆集会记录下别的Region指向自己和标记这些指针分别在哪些卡页的范围内

##### G1如何建立可靠的停顿预测模型

- G1的停顿预测模型是以衰减均值（更受最新数据影响）为理论基础实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并得出平均值、标准偏差、置信度等统计信息

##### G1收集器运行过程

1. 初始标记：标记一下GC Roots能关联到的对象，并修改TAMS指针的值
2. 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆的对象图，找出要回收的对象
3. 最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后遗留的少量的SATB记录
4. 筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间制定回收计划，然后选择一定的Region作为回收集，采用复制清除算法进行回收

#### 低延迟垃圾收集器



#### Shenandoah收集器



#### ZGC收集器