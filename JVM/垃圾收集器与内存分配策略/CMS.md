### CMS

- 是一款以获取最短停顿时间为目标的老年代垃圾收集器，基于标记-清除算法实现，适用于对交互速度要求较高的场合



#### CMS的垃圾收集过程

四个阶段：

- 初始标记
- 并发标记
- 重新标记
- 并发清除

##### 初始标记

- 初始标记需要stw，它会标记可达性分析算法中所有能被选为根节点的对象（虚拟机栈引用的对象、方法区中静态属性与常量引用的对象、JNI引用的对象、虚拟机内部的引用），这部分标记被记录在Oop中，所以初始标记很快

##### 并发标记

- 并发标记阶段会根据初始标记阶段标记的对象做可达性分析，这个过程较长但不需要停止用户线程；由于在这期间用户线程可能会改变对象的引用，所以需要通过“写前屏障”来解决“对象消失”问题

##### 重新标记

- 重新标记需要stw，基于增量更新的方式对在并发标记期间发生对象引用改变的对象进行遍历标记

##### 并发清除

- 并发清除不需要停顿用户线程，它只会清除之前标记了需要回收的对象，

#### CMS存在的问题

- 对处理器资源敏感

- 浮动垃圾
- 碎片空间

##### 对处理器资源敏感

- 事实上，所有面向并发设计的程序都对处理器资源敏感；在并发阶段，CMS虽然不会导致用户线程停顿，但是会占用cpu资源而导致吞吐量下降，CMS默认启动的回收线程数为 处理器核心数/4 + 3/4 个线程

##### 浮动垃圾

- 在并发清除期间产生的垃圾不会被回收，叫做浮动垃圾，需要等待下一次垃圾收集再回收，所以需要预留出足够的内存空间给用户使用，否则可能会导致完全停顿用户线程的Full GC出现，并启用预备的垃圾收集器Serial Old；这个设置预留空间的参数叫做-XX:CMSInitiatingOccupancyFraction

##### 碎片空间

- 由于CMS是基于标记-清除算法的，所以它没有能力解决碎片空间的问题，即可能出现由于没有连续的足够大的空间分配给一个大的对象的问题而导致Full GC；CMS提供了缓解的方式，在JDK1.9之后被废弃的参数：+XX:UseCMSCompactAtFullCollection和-XX:CMSFullGCsBeforeCompaction，前者用于在CMS不得不进行Full GC之前开启内存碎片的合并整理过程，这个内存整理过程必须移动存活对象，是无法并发的，后面这个参数表示执行若干次不整理空间的Full GC之后，在下一次Full GC之前来一次空间整理